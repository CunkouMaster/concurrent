# 核心思想 #
1. 当CPU写入数据时，如果发现该变量被共享（在其他CPU中存在该变量副本），会发出一个信号，通知其他CPU该变量的缓冲无效；
1. 当其他CPU访问该变量时，重新到主内存进行获取。

----------
# 并发编程三个重要概念：   #
1. 	**原子性**（一个或多个操作要么都成功,要么都失败，中间不能由于任何的因素终端）；  
1. 	**可见性**；  
1. 	**有序性**（顺序性）； *重排序只要求最终一致性* 

----------
# JAVA如何保证原子性、可见性、有序性： #
1. **原子性**：对基本数据类型的变量读取和赋值是保证了原子性的。  
1. **可见性**：使用volatile关键字保证可见性。  
1. **有序性**：happens-before relationship  
	*a.代码的执行顺序，编写在前面的发生在编写在后面的；*  
	*b. unlock必须发生在lock之后；*  
    *c. volatile修饰的变量，对一个变量的写操作先于对该变量的读操作；*  
	*d.传递规则，操作A先于B，B先于C，那么A肯定先于C；*  
	*e.线程启动规则，start方法肯定先于run方法；*  
	*f.线程中断规则，interrupt动作必须发生在捕获该动作之前；*  
	*g.对象销毁规则，初始化必须发生在finalize之前；*  
	*h.线程终结规则，所有操作发生在线程死亡之前。*  

----------
# volatile关键字： #
*（一旦一个共享变量被volatile关键字修饰，具备两层语义）*  

1. 保证了不同线程间的可见性；  
1. 禁止对其进行重排序，也就保证了有序性；  
1. 并未保证原子性。

总结：  

1. 保证重排序的时候不会把后面的指令放到屏障的前面，也不会把前面的放到后面；  
1. 强制对缓存的修改操作立即写入主存；  
1. 如果是写操作，会导致其他CPU中缓存失效；


----------
# volatile使用场景： #
1. 状态量标记：  

    	volatile boolean start = true;  
    	while(start){  
    		//  
    	}  
    	void close(){  
    		start = false;  
    	}
1. 屏障前后一致性：
	
    	volatile boolean init;  
    	//--- thread 1 ---  
    	obj = createObj();  
    	init = true;
    	//--- thread 2 ---
    	while(!init){
    		sleep();	
    	}
    	useTheObj(obj);